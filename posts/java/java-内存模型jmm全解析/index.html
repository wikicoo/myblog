<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>JVM基础：Java 内存模型（JMM）全解析 - Fulur</title><meta name=Description content="This is my cool site"><meta property="og:url" content="http://example.org/posts/java/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bjmm%E5%85%A8%E8%A7%A3%E6%9E%90/">
<meta property="og:site_name" content="Fulur"><meta property="og:title" content="JVM基础：Java 内存模型（JMM）全解析"><meta property="og:description" content="一、引言：为什么需要 Java 内存模型？ 在单线程程序中，变量的读取和写入是直观且一致的。但一旦进入多线程环境，情况就复杂得多——一个线程对变量所做的修改，另一个线程可能看不到，也可能看到不一致的中间状态。更令人困惑的是，这种问题即使在没有显式锁的代码中也可能悄然发生。你写下的代码语义清晰、逻辑无误，但却因为“看不见的顺序”而出现诡异的 bug。"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-28T17:52:52+08:00"><meta property="article:modified_time" content="2025-04-28T17:52:52+08:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="JVM"><meta name=twitter:card content="summary"><meta name=twitter:title content="JVM基础：Java 内存模型（JMM）全解析"><meta name=twitter:description content="一、引言：为什么需要 Java 内存模型？ 在单线程程序中，变量的读取和写入是直观且一致的。但一旦进入多线程环境，情况就复杂得多——一个线程对变量所做的修改，另一个线程可能看不到，也可能看到不一致的中间状态。更令人困惑的是，这种问题即使在没有显式锁的代码中也可能悄然发生。你写下的代码语义清晰、逻辑无误，但却因为“看不见的顺序”而出现诡异的 bug。"><meta name=application-name content="My cool site"><meta name=apple-mobile-web-app-title content="My cool site"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=http://example.org/posts/java/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bjmm%E5%85%A8%E8%A7%A3%E6%9E%90/><link rel=prev href=http://example.org/posts/java/%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E4%B8%8E-jvm-%E5%8F%82%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB%E8%AF%A6%E8%A7%A3/><link rel=next href=http://example.org/posts/java/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A8%A1%E5%9E%8B/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"JVM基础：Java 内存模型（JMM）全解析","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/example.org\/posts\/java\/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bjmm%E5%85%A8%E8%A7%A3%E6%9E%90\/"},"genre":"posts","keywords":"java, JVM","wordcount":5581,"url":"http:\/\/example.org\/posts\/java\/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bjmm%E5%85%A8%E8%A7%A3%E6%9E%90\/","datePublished":"2025-04-28T17:52:52+08:00","dateModified":"2025-04-28T17:52:52+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"fulu"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=Fulur>Fulur</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=Fulur>Fulur</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">JVM基础：Java 内存模型（JMM）全解析</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>fulu</a></span>&nbsp;<span class=post-category>included in <a href=/categories/jvm%E5%9F%BA%E7%A1%80/><i class="far fa-folder fa-fw" aria-hidden=true></i>JVM基础</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2025-04-28>2025-04-28</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;5581 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;12 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#一引言为什么需要-java-内存模型>一、引言：为什么需要 Java 内存模型？</a><ul><li><a href=#并发编程中的三个核心问题>并发编程中的三个核心问题</a></li><li><a href=#为什么不能只依赖硬件或操作系统>为什么不能只依赖硬件或操作系统？</a></li><li><a href=#jmmjava-层的并发契约>JMM：Java 层的并发“契约”</a></li><li><a href=#举个实际例子变量失效问题>举个实际例子：变量失效问题</a></li></ul></li><li><a href=#二jmm-的抽象模型与基本规则>二、JMM 的抽象模型与基本规则</a><ul><li><a href=#主内存main-memory与工作内存working-memory>主内存（Main Memory）与工作内存（Working Memory）</a></li><li><a href=#工作内存与主内存的交互指令8个>工作内存与主内存的交互指令（8个）</a></li><li><a href=#内存访问规则>内存访问规则</a></li><li><a href=#示意图jmm-的线程与主内存模型>示意图：JMM 的线程与主内存模型</a></li><li><a href=#小结>小结</a></li></ul></li><li><a href=#三happens-before-原则>三、Happens-Before 原则</a><ul><li><a href=#什么是-happens-before>什么是 happens-before？</a></li><li><a href=#jmm-中的-happens-before-规则重点>JMM 中的 happens-before 规则（重点）</a></li><li><a href=#volatile-如何保证可见性>volatile 如何保证可见性？</a></li><li><a href=#volatile-是否保证原子性>volatile 是否保证原子性？</a></li></ul></li><li><a href=#四有序性与指令重排序>四、有序性与指令重排序</a><ul><li><a href=#为什么有序性重要>为什么有序性重要？</a></li><li><a href=#什么是指令重排序>什么是指令重排序？</a></li><li><a href=#jmm-如何限制重排序>JMM 如何限制重排序？</a></li><li><a href=#指令重排序带来的并发错误示例>指令重排序带来的并发错误示例</a></li></ul></li><li><a href=#五原子性与-java-中的原子操作>五、原子性与 Java 中的原子操作</a><ul><li><a href=#什么是原子性>什么是原子性？</a></li><li><a href=#java-中的非原子操作示例>Java 中的非原子操作示例</a></li><li><a href=#如何在-java-中保证原子性>如何在 Java 中保证原子性？</a></li><li><a href=#cas-的底层原理>CAS 的底层原理</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#六可见性与内存屏障机制>六、可见性与内存屏障机制</a><ul><li><a href=#什么是可见性>什么是可见性？</a></li><li><a href=#可见性的实现机制内存屏障memory-barrier>可见性的实现机制：内存屏障（Memory Barrier）</a></li><li><a href=#volatile-的内存语义jmm-语义><code>volatile</code> 的内存语义（JMM 语义）</a></li><li><a href=#使用-synchronized-是否也保证可见性>使用 <code>synchronized</code> 是否也保证可见性？</a></li><li><a href=#小结-1>小结</a></li></ul></li></ul></nav></div></div><div class=content id=content><h2 id=一引言为什么需要-java-内存模型>一、引言：为什么需要 Java 内存模型？</h2><p>在单线程程序中，变量的读取和写入是直观且一致的。但一旦进入多线程环境，情况就复杂得多——一个线程对变量所做的修改，另一个线程可能<strong>看不到</strong>，也可能<strong>看到不一致的中间状态</strong>。更令人困惑的是，这种问题即使在没有显式锁的代码中也可能悄然发生。你写下的代码语义清晰、逻辑无误，但却因为“看不见的顺序”而出现诡异的 bug。</p><p>这背后正是 <strong>Java 内存模型（Java Memory Model, JMM）</strong> 所要解决的问题。</p><hr><h3 id=并发编程中的三个核心问题>并发编程中的三个核心问题</h3><p>Java 内存模型主要为了解决三个问题：</p><ol><li><strong>原子性（Atomicity）</strong>：一个操作是否不可被打断</li><li><strong>可见性（Visibility）</strong>：一个线程对变量的修改对其他线程是否可见</li><li><strong>有序性（Ordering）</strong>：程序的执行顺序是否和代码顺序一致</li></ol><p>JMM 的设计目的，就是在保证这三者之间合理权衡的同时，<strong>让 Java 程序在多线程下依然能够跨平台正确运行</strong>。</p><hr><h3 id=为什么不能只依赖硬件或操作系统>为什么不能只依赖硬件或操作系统？</h3><p>在现代硬件架构中：</p><ul><li><strong>CPU 有多级缓存</strong>，线程可能只读写自己的缓存而非主内存</li><li><strong>编译器会优化代码执行顺序</strong>，比如将某些语句重排序以提高性能</li><li><strong>不同 CPU 有不同的内存一致性模型（如 x86 vs ARM）</strong></li></ul><p>这些差异导致，如果没有统一的规范，那么<strong>相同的 Java 代码在不同平台上会表现出不同的并发行为</strong>。这对 Java 的“跨平台”哲学是个巨大威胁。</p><hr><h3 id=jmmjava-层的并发契约>JMM：Java 层的并发“契约”</h3><p>为了解决上述问题，Java 在语言级别提出了一套规范——Java 内存模型，它并不是 CPU 的物理内存模型，而是：</p><ul><li>一套 <strong>行为规范</strong>（specification）：描述多线程之间读写共享变量时应遵循的规则</li><li>一种 <strong>抽象语义模型</strong>：屏蔽硬件差异，在语义层面保证程序执行的一致性</li><li>并通过 <code>volatile</code>、<code>synchronized</code>、<code>final</code> 等语言关键字来进行控制</li></ul><p>JMM 使得开发者可以用统一的方式来思考并发问题，而不需要关心底层平台的指令级差异。</p><hr><h3 id=举个实际例子变量失效问题>举个实际例子：变量失效问题</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Flag</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>static</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=n>stop</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>stop</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// do something</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}).</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>Thread</span><span class=p>.</span><span class=na>sleep</span><span class=p>(</span><span class=n>1000</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>InterruptedException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>stop</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>你期望 1 秒后主线程将 <code>stop</code> 设置为 true，子线程跳出循环。但很可能子线程<strong>永远不会结束</strong>！</p><p>为什么？因为子线程<strong>可能只从 CPU 缓存中读取 <code>stop</code></strong>，而根本不知道主线程已经修改了它。这种现象，正是 <strong>JMM 中可见性问题的典型代表</strong>。</p><p>解决方法之一就是将 <code>stop</code> 声明为 <code>volatile</code>，告诉 JVM：这个变量<strong>不能缓存，必须直接从主内存读取</strong>。</p><hr><h2 id=二jmm-的抽象模型与基本规则>二、JMM 的抽象模型与基本规则</h2><p>Java 内存模型的核心是一种<strong>抽象的、面向线程与主内存交互的模型</strong>。理解这个模型，是掌握 JMM 的关键第一步。</p><hr><h3 id=主内存main-memory与工作内存working-memory>主内存（Main Memory）与工作内存（Working Memory）</h3><p>JMM 将每一个线程的执行环境分为两个部分：</p><ul><li><strong>主内存（Main Memory）</strong>：所有线程共享的内存区域，存储所有的实例字段、静态字段等（即共享变量）</li><li><strong>工作内存（Working Memory）</strong>：每个线程<strong>私有</strong>的内存区域，用于保存该线程使用的变量的副本（类似 CPU 的寄存器或高速缓存）</li></ul><p>线程对变量的所有操作（读取、写入），必须<strong>先从主内存复制到工作内存中再操作</strong>，并<strong>在操作后刷新回主内存</strong>。</p><p><strong>注意：局部变量不在 JMM 控制之内，它们存储在栈帧中，不共享，因此不存在并发问题。</strong></p><hr><h3 id=工作内存与主内存的交互指令8个>工作内存与主内存的交互指令（8个）</h3><p>Java 内存模型定义了 8 个用于线程与主内存交互的低级指令：</p><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td><code>load</code></td><td>从主内存中读取变量值到工作内存</td></tr><tr><td><code>store</code></td><td>将工作内存中的变量值写回主内存</td></tr><tr><td><code>read</code></td><td>从主内存中复制变量到工作内存中（依赖于 load）</td></tr><tr><td><code>write</code></td><td>将变量从工作内存写入主内存（依赖于 store）</td></tr><tr><td><code>use</code></td><td>将工作内存中的变量值传递给执行引擎</td></tr><tr><td><code>assign</code></td><td>执行引擎将值赋给变量，存入工作内存</td></tr><tr><td><code>lock</code></td><td>对变量加锁（用于 synchronized）</td></tr><tr><td><code>unlock</code></td><td>对变量解锁（释放锁的过程会强制刷新到主内存）</td></tr></tbody></table><p>虽然我们在写代码时看不到这些指令，但 JVM 会在字节码层隐式使用它们。</p><hr><h3 id=内存访问规则>内存访问规则</h3><p>JMM 对上述指令有以下规则：</p><ul><li>一个变量在没有 <code>load</code> 之前不能 <code>use</code> 或 <code>assign</code></li><li>一个变量在 <code>assign</code> 之后必须 <code>store</code> 才能 <code>write</code> 到主内存</li><li>同一个变量的操作必须串行进行（不允许并发 <code>load</code>/<code>store</code>）</li><li>每个变量在每个线程中都有独立的副本</li></ul><hr><h3 id=示意图jmm-的线程与主内存模型>示意图：JMM 的线程与主内存模型</h3><p>下面是一张简化的示意图：</p><pre tabindex=0><code>        主内存（Main Memory）
      -------------------------
     |      变量x     变量y     |
      -------------------------
         ↑           ↑
         |           |
         ↓           ↓
线程 A 的工作内存        线程 B 的工作内存
 -------------------    -------------------
| 副本x_A    副本y_A |  | 副本x_B    副本y_B |
 -------------------    -------------------

操作顺序：
1. 线程A -&gt; load(x) -&gt; read(x) -&gt; use/assign(x)
2. assign(x) -&gt; store(x) -&gt; write(x) -&gt; 主内存
</code></pre><p>每个线程从主内存读取变量的副本放入自己的工作内存中，在那里进行修改，然后再同步回主内存。<strong>如果不刷新，其他线程是看不到这个修改的</strong>，这就是<strong>可见性问题的来源</strong>。</p><hr><h3 id=小结>小结</h3><ul><li>线程对共享变量的修改，<strong>默认不会立刻对其他线程可见</strong></li><li>想要让别的线程看到你的修改，必须<strong>显式同步（如 volatile、锁）</strong></li><li>JMM 的模型可以看作是：<strong>线程=操作缓存；主内存=真实世界</strong></li></ul><hr><h2 id=三happens-before-原则>三、Happens-Before 原则</h2><p>为了解决这些看不见的问题，Java 内存模型引入了一个关键的“可见性”规范 —— happens-before（先行发生）关系。</p><h3 id=什么是-happens-before>什么是 happens-before？</h3><p>如果操作 A happens-before 操作 B，那么：</p><ul><li>操作 A 的结果对于操作 B 是<strong>可见的</strong></li><li>操作 A 的执行顺序在操作 B 之前</li></ul><p><strong>注意</strong>：happens-before 并不是“物理时钟上的先后”，而是一种<strong>程序行为的逻辑顺序保证</strong></p><h3 id=jmm-中的-happens-before-规则重点>JMM 中的 happens-before 规则（重点）</h3><ol><li><strong>程序顺序规则</strong>：一个线程内，代码的执行顺序就是 happens-before 顺序。</li><li><strong>锁规则</strong>：一个线程对锁的 unlock 操作，happens-before 之后另一个线程对同一锁的 lock 操作。</li><li><strong>volatile 变量规则</strong>：对一个 volatile 变量的写操作，happens-before 于后续对该变量的读操作。</li><li><strong>线程启动规则</strong>：线程 A 启动线程 B（即 <code>Thread.start()</code>），则 A 中的 start happens-before 于 B 线程的任意操作。</li><li><strong>线程终止规则</strong>：线程中的所有操作 happens-before 于其他线程检测到它已经终止（比如 <code>Thread.join()</code> 返回）。</li><li><strong>对象构造规则</strong>：构造函数中的所有操作在对象被另一个线程看到之前都必须完成（除非 this 泄露）。</li></ol><p>这些规则共同构成了 Java 并发程序在内存层面的行为保障。</p><h3 id=volatile-如何保证可见性>volatile 如何保证可见性？</h3><p>JVM 对 <code>volatile</code> 做了两件事：</p><ol><li><strong>禁止重排序</strong>：对于 <code>volatile</code> 写操作，编译器和处理器不允许把它与前后的读写操作重排序；</li><li><strong>强制刷新主内存</strong>：写入 <code>volatile</code> 的变量会立刻写入主内存，而读操作会从主内存中重新读取。</li></ol><p>这就避免了工作内存缓存变量所造成的可见性失效问题。</p><h3 id=volatile-是否保证原子性>volatile 是否保证原子性？</h3><p><strong>不保证。</strong></p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>volatile</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>count</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>count</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>虽然 <code>count</code> 是 volatile，但 <code>++</code> 不是原子操作。它包含了读、加一、写三个步骤，仍可能在多线程环境下发生竞态条件。</p><p>想保证原子性，需使用锁（如 synchronized）或原子类（如 <code>AtomicInteger</code>）。</p><h2 id=四有序性与指令重排序>四、有序性与指令重排序</h2><h3 id=为什么有序性重要>为什么有序性重要？</h3><p>在单线程程序中，我们天然相信代码是<strong>从上到下、顺序执行</strong>的。</p><p>但在并发程序中，CPU、编译器、JVM 为了优化性能，<strong>可能会调整代码的执行顺序</strong>。这并不是 bug，而是设计使然。但它会破坏我们对代码行为的直觉认知，从而引发并发错误。</p><p>例如，在没有同步保障的情况下，以下代码的执行顺序可能被改变：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>int</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>int</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>int</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>b</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>可能会被重排序成：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>int</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>int</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>int</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>b</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>在单线程下这不会出问题，但在多线程下就可能造成严重后果。</p><p>以下示例可以复现这种现象</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>InstructionReorder</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>1000000</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>final</span><span class=w> </span><span class=n>ReorderMe</span><span class=w> </span><span class=n>reorderMe</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ReorderMe</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>reorderMe</span><span class=p>.</span><span class=na>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>reorderMe</span><span class=p>.</span><span class=na>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>reorderMe</span><span class=p>.</span><span class=na>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>reorderMe</span><span class=p>.</span><span class=na>a</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>reorderMe</span><span class=p>.</span><span class=na>b</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}).</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kt>int</span><span class=w> </span><span class=n>tmpa</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>reorderMe</span><span class=p>.</span><span class=na>a</span><span class=p>,</span><span class=w> </span><span class=n>tmpb</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>reorderMe</span><span class=p>.</span><span class=na>b</span><span class=p>,</span><span class=w> </span><span class=n>tmpc</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>reorderMe</span><span class=p>.</span><span class=na>c</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=p>(</span><span class=n>tmpb</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>2</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>tmpa</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Instruction Reordering: a = &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>tmpa</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;, b = &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>tmpb</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;, c = &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>tmpc</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=p>(</span><span class=n>tmpc</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>0</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>tmpa</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Instruction Reordering: a = &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>tmpa</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;, b = &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>tmpb</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;, c = &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>tmpc</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=p>(</span><span class=n>tmpc</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>0</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>tmpb</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Instruction Reordering: a = &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>tmpa</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;, b = &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>tmpb</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;, c = &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>tmpc</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}).</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>static</span><span class=w> </span><span class=kd>class</span> <span class=nc>ReorderMe</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>输出： Instruction Reordering: <span class=nv>a</span> <span class=o>=</span> 1, <span class=nv>b</span> <span class=o>=</span> 0, <span class=nv>c</span> <span class=o>=</span> <span class=m>3</span>
</span></span></code></pre></div><hr><h3 id=什么是指令重排序>什么是指令重排序？</h3><p>JMM 下的指令重排序分为三个层次：</p><ol><li><strong>编译器重排序</strong>：Java 编译器在生成字节码时，为了优化性能，可能会重排语句顺序；</li><li><strong>指令级重排序</strong>：JVM 指令到机器指令的转换过程中，JIT 编译器可能改变执行顺序；</li><li><strong>CPU 重排序</strong>：处理器出于流水线和乱序执行等目的，也会对指令顺序进行动态调整。</li></ol><p>注意：这些重排序都<strong>不影响单线程语义</strong>，但会对多线程造成影响。</p><hr><h3 id=jmm-如何限制重排序>JMM 如何限制重排序？</h3><p>Java 内存模型通过 <strong>happens-before</strong> 关系和特定的关键字（如 <code>volatile</code>、<code>synchronized</code>）来约束重排序的范围，从而维持程序在多线程中的正确性。</p><p>以下操作具有<strong>内存屏障</strong>效果，用来限制或禁止重排序：</p><h4 id=synchronized>synchronized</h4><p><code>synchronized</code> 的进入和退出，JVM 会插入<strong>MonitorEnter 和 MonitorExit</strong>指令。这些操作会触发内存屏障：</p><ul><li><strong>锁的释放（unlock）前</strong>：线程必须将工作内存中对共享变量的修改刷新到主内存。</li><li><strong>锁的获取（lock）后</strong>：线程必须从主内存中重新读取共享变量的值。</li></ul><p>因此，synchronized 能<strong>同时保证原子性、可见性、有序性</strong>。</p><h4 id=volatile>volatile</h4><p>JVM 在访问 volatile 变量时会插入特定的读写屏障：</p><ul><li><strong>volatile 写入之前</strong>：会插入 <code>storestore</code> 屏障，禁止与之前的写重排序；</li><li><strong>volatile 写入之后</strong>：插入 <code>storeload</code> 屏障，禁止之后的读写指令提前执行；</li><li><strong>volatile 读取之前</strong>：插入 <code>loadload</code> 屏障；</li><li><strong>volatile 读取之后</strong>：插入 <code>loadstore</code> 屏障；</li></ul><p>这些屏障使得 volatile 变量的写对其他线程“立刻可见”，并阻止读写操作的重排序。</p><hr><h3 id=指令重排序带来的并发错误示例>指令重排序带来的并发错误示例</h3><p>以下代码存在严重的重排序风险：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Singleton</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Singleton</span><span class=w> </span><span class=n>instance</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Singleton</span><span class=w> </span><span class=nf>getInstance</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>instance</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>               </span><span class=c1>// ①</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>synchronized</span><span class=w> </span><span class=p>(</span><span class=n>Singleton</span><span class=p>.</span><span class=na>class</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>instance</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>       </span><span class=c1>// ②</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>instance</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Singleton</span><span class=p>();</span><span class=w> </span><span class=c1>// ③</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>instance</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>上述“DCL”（双重检查锁）写法是<strong>错误的</strong>，因为 <code>new Singleton()</code> 实际上分为三步：</p><ol><li>分配内存；</li><li>调用构造函数初始化；</li><li>将引用赋值给 <code>instance</code>；</li></ol><p>如果发生指令重排序，使得 3 在 2 前执行，另一个线程可能拿到一个“未初始化完成”的对象。</p><p>解决方案：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>volatile</span><span class=w> </span><span class=n>Singleton</span><span class=w> </span><span class=n>instance</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>加入 <code>volatile</code> 后，禁止了对象初始化的指令重排序，从而保证了线程安全。</p><h2 id=五原子性与-java-中的原子操作>五、原子性与 Java 中的原子操作</h2><h3 id=什么是原子性>什么是原子性？</h3><p><strong>原子性（Atomicity）<strong>是指一个操作</strong>不可分割</strong>，即使在多线程环境下，也不会被中断或看到“中间状态”。</p><p>一个操作如果具有原子性，那么对其他线程来说，要么操作已经完成，要么尚未开始，<strong>绝不会看到“操作一半”的状态</strong>。</p><hr><h3 id=java-中的非原子操作示例>Java 中的非原子操作示例</h3><p>最经典的非原子性示例是 <code>i++</code> 操作，看似一个语句，实际包含多个步骤：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>i</span><span class=o>++</span><span class=p>;</span><span class=w> </span><span class=c1>// 实际包含：</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>1</span><span class=p>.</span><span class=w> </span><span class=n>读取</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=n>的值到工作内存</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>2</span><span class=p>.</span><span class=w> </span><span class=n>执行</span><span class=w> </span><span class=o>+</span><span class=n>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>3</span><span class=p>.</span><span class=w> </span><span class=n>写回</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=n>到主内存</span><span class=w>
</span></span></span></code></pre></div><p>在多线程下，若两个线程同时执行 <code>i++</code>，可能造成如下情况：</p><ol><li>线程 A 读到 i = 1；</li><li>线程 B 也读到 i = 1；</li><li>两者都 +1，写回结果为 2；</li><li>最终结果为 2，而不是期望的 3。</li></ol><p>这种行为就违反了原子性。</p><hr><h3 id=如何在-java-中保证原子性>如何在 Java 中保证原子性？</h3><h4 id=1-使用-synchronized>1. 使用 <code>synchronized</code></h4><p><code>synchronized</code> 是最基本的原子性保障手段，通过<strong>对象锁或类锁</strong>，在进入临界区前保证<strong>互斥访问</strong>，避免线程之间交叉执行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>synchronized</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>increment</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>i</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>或</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>increment</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>synchronized</span><span class=w> </span><span class=p>(</span><span class=k>this</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>i</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><code>synchronized</code> 同时保障原子性、可见性和有序性，但性能可能较低。</p><hr><h4 id=2-使用-reentrantlock>2. 使用 <code>ReentrantLock</code></h4><p><code>java.util.concurrent.locks.ReentrantLock</code> 是比 <code>synchronized</code> 更灵活的可重入锁，也能保证原子性。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Lock</span><span class=w> </span><span class=n>lock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ReentrantLock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>lock</span><span class=p>.</span><span class=na>lock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>i</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>lock</span><span class=p>.</span><span class=na>unlock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>它支持尝试锁、定时锁、公平锁等扩展能力。</p><hr><h4 id=3-使用-volatile不能保证原子性>3. 使用 <code>volatile</code>？不能保证原子性！</h4><p>一个常见误区是使用 <code>volatile</code> 变量来避免竞态。但 <code>volatile</code> 仅能保证<strong>可见性</strong>和<strong>禁止重排序</strong>，<strong>不能保证原子性</strong>。</p><p>例如以下代码并不线程安全：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kd>volatile</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>count</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>increment</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>count</span><span class=o>++</span><span class=p>;</span><span class=w> </span><span class=c1>// 非原子操作</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>即便每个线程都能“看见”最新的值，但它们还是可能在读取到旧值的基础上计算，从而丢失更新。</p><hr><h4 id=4-使用原子类atomic>4. 使用原子类（Atomic*）</h4><p>JDK 提供了一组基于 <strong>CAS（Compare And Swap）</strong> 的原子类，可以无锁地保证单个变量的原子更新。</p><p>如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>AtomicInteger</span><span class=w> </span><span class=n>counter</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>AtomicInteger</span><span class=p>(</span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>counter</span><span class=p>.</span><span class=na>incrementAndGet</span><span class=p>();</span><span class=w>  </span><span class=c1>// 原子性 +1</span><span class=w>
</span></span></span></code></pre></div><p>常用原子类包括：</p><ul><li><code>AtomicInteger</code> / <code>AtomicLong</code> / <code>AtomicBoolean</code></li><li><code>AtomicReference</code></li><li><code>AtomicStampedReference</code>（解决 ABA 问题）</li><li><code>AtomicIntegerArray</code> / <code>AtomicLongArray</code> 等</li></ul><p>底层依赖于 JVM 的 <strong>Unsafe.compareAndSwapInt()</strong> 等方法实现。</p><hr><h3 id=cas-的底层原理>CAS 的底层原理</h3><p>CAS 是一条原子性 CPU 指令，流程为：</p><pre tabindex=0><code>如果当前值 == 预期值：
    则更新为新值
否则：
    什么也不做
</code></pre><p>这类指令由硬件提供，可以无需加锁就实现并发更新，性能更优。</p><p>CAS 三大问题：</p><ol><li><strong>ABA 问题</strong>：值 A → B → A，CAS 无法感知变化；</li><li><strong>自旋开销</strong>：CAS 会自旋重试，可能耗 CPU；</li><li><strong>只能保障单变量</strong>：多个变量的一致更新无法用 CAS 保证，需要 <code>AtomicReferenceFieldUpdater</code> 等更复杂手段。</li></ol><hr><h3 id=总结>总结</h3><table><thead><tr><th>手段</th><th>可见性</th><th>原子性</th><th>有序性</th><th>适用场景</th></tr></thead><tbody><tr><td><code>volatile</code></td><td>✅</td><td>❌</td><td>✅</td><td>状态标志、单变量只读写</td></tr><tr><td><code>synchronized</code></td><td>✅</td><td>✅</td><td>✅</td><td>互斥操作，临界区控制</td></tr><tr><td><code>ReentrantLock</code></td><td>✅</td><td>✅</td><td>✅</td><td>复杂并发控制（如公平锁）</td></tr><tr><td><code>AtomicInteger</code></td><td>✅</td><td>✅</td><td>❌</td><td>单变量频繁更新，高性能场景</td></tr></tbody></table><h2 id=六可见性与内存屏障机制>六、可见性与内存屏障机制</h2><h3 id=什么是可见性>什么是可见性？</h3><p><strong>可见性（Visibility）<strong>是指</strong>一个线程对共享变量的修改，能被其他线程立即看到</strong>。</p><p>在多线程环境中，Java 会为每个线程分配一块 <strong>工作内存（线程本地缓存）</strong>。当线程读取或写入变量时，可能只作用于自己的工作内存，不会立刻刷新到主内存。</p><p>因此，某线程对变量的更改可能对其他线程<strong>不可见</strong>，就会出现“读到旧值”的问题。</p><hr><h3 id=可见性的实现机制内存屏障memory-barrier>可见性的实现机制：内存屏障（Memory Barrier）</h3><p>Java 的可见性保障离不开底层 <strong>内存屏障（memory barrier）/内存栅栏</strong> 的支持。</p><p>当你使用：</p><ul><li><code>volatile</code></li><li><code>synchronized</code></li><li><code>final</code>（构造完成前的只读语义）</li></ul><p>JVM 会在合适的位置插入内存屏障，以限制指令重排序并强制刷新主内存。</p><h4 id=常见屏障类型>常见屏障类型：</h4><ol><li><code>StoreStore Barrier</code>：确保前面的写操作先于后面的写操作；</li><li><code>LoadLoad Barrier</code>：确保前面的读操作先于后面的读操作；</li><li><code>LoadStore Barrier</code>：确保前面的读操作先于后面的写操作；</li><li><code>StoreLoad Barrier</code>：<strong>最强屏障</strong>，确保前面的写操作对其他线程可见，必须在其后的读操作之前完成。</li></ol><hr><h3 id=volatile-的内存语义jmm-语义><code>volatile</code> 的内存语义（JMM 语义）</h3><p>对 <code>volatile</code> 变量的读写，在字节码中表现为 <code>volatile</code> 指令（如 <code>getfield volatile</code> 和 <code>putfield volatile</code>），JVM 在这些操作前后会插入内存屏障：</p><h4 id=写操作时>写操作时：</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>putfield</span><span class=w> </span><span class=kd>volatile</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>StoreStore</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>StoreLoad</span><span class=w>
</span></span></span></code></pre></div><ul><li>写入前，先将前面的所有写刷新；</li><li>写完后，禁止之后的读写操作重排序。</li></ul><h4 id=读操作时>读操作时：</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>getfield</span><span class=w> </span><span class=kd>volatile</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>LoadLoad</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>LoadStore</span><span class=w>
</span></span></span></code></pre></div><ul><li>读之前，确保之后的读不会重排序；</li><li>读之后，禁止后续的写操作提前。</li></ul><p>这样确保了<strong>写入操作对其他线程可见</strong>，也禁止了某些重排序，保证线程间的数据一致性。</p><hr><h3 id=使用-synchronized-是否也保证可见性>使用 <code>synchronized</code> 是否也保证可见性？</h3><p>是的。</p><p><code>synchronized</code> 的进入和退出操作分别对应：</p><ul><li>进入临界区：<strong>读取主内存中的变量值到工作内存中</strong>；</li><li>退出临界区：<strong>强制将工作内存中的修改刷新到主内存中</strong>。</li></ul><p>因此它天然具有可见性保障。</p><hr><h3 id=小结-1>小结</h3><table><thead><tr><th>可见性保障手段</th><th>是否保证可见性</th><th>是否保证原子性</th><th>是否禁止重排序</th></tr></thead><tbody><tr><td><code>volatile</code></td><td>✅</td><td>❌</td><td>✅（部分）</td></tr><tr><td><code>synchronized</code></td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>原子类（CAS）</td><td>✅（依赖内存屏障）</td><td>✅</td><td>✅（部分）</td></tr></tbody></table><p><strong>可见性是并发编程中最容易被忽视的问题</strong>，很多程序在单线程或低并发环境中运行良好，一旦在多核高并发环境中部署，就会出现“莫名其妙”的读错数据的问题，根本原因就是<strong>可见性丧失</strong>。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2025-04-28</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=http://example.org/posts/java/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bjmm%E5%85%A8%E8%A7%A3%E6%9E%90/ data-title="JVM基础：Java 内存模型（JMM）全解析" data-hashtags=java,JVM><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=http://example.org/posts/java/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bjmm%E5%85%A8%E8%A7%A3%E6%9E%90/ data-hashtag=java><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=http://example.org/posts/java/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bjmm%E5%85%A8%E8%A7%A3%E6%9E%90/ data-title="JVM基础：Java 内存模型（JMM）全解析"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=http://example.org/posts/java/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bjmm%E5%85%A8%E8%A7%A3%E6%9E%90/ data-title="JVM基础：Java 内存模型（JMM）全解析"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=http://example.org/posts/java/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bjmm%E5%85%A8%E8%A7%A3%E6%9E%90/ data-title="JVM基础：Java 内存模型（JMM）全解析"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/java/>Java</a>,&nbsp;<a href=/tags/jvm/>JVM</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/java/%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E4%B8%8E-jvm-%E5%8F%82%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB%E8%AF%A6%E8%A7%A3/ class=prev rel=prev title="JVM基础：对象大小与 JVM 参数的关系详解"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>JVM基础：对象大小与 JVM 参数的关系详解</a>
<a href=/posts/java/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A8%A1%E5%9E%8B/ class=next rel=next title="JVM基础：Java 虚拟机模型">JVM基础：Java 虚拟机模型<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.146.7">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.3.0"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2022 - 2025</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>xxxx</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>