<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>JVM基础：Java对象的创建与内存布局：你以为的 new 不止 new - Fulur</title><meta name=Description content="This is my cool site"><meta property="og:url" content="http://example.org/posts/java/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/">
<meta property="og:site_name" content="Fulur"><meta property="og:title" content="JVM基础：Java对象的创建与内存布局：你以为的 new 不止 new"><meta property="og:description" content="你真的理解 new 吗？ “Java 中创建一个对象，不就是 new 一下吗？”这是许多开发者对对象创建的第一印象。但如果你曾经在生产环境遇到内存泄漏、对象占用过大，或者面试时被问“对象在内存中长什么样”，你可能就会意识到，事情没有那么简单。"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-27T16:52:52+08:00"><meta property="article:modified_time" content="2025-04-27T16:52:52+08:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="JVM"><meta name=twitter:card content="summary"><meta name=twitter:title content="JVM基础：Java对象的创建与内存布局：你以为的 new 不止 new"><meta name=twitter:description content="你真的理解 new 吗？ “Java 中创建一个对象，不就是 new 一下吗？”这是许多开发者对对象创建的第一印象。但如果你曾经在生产环境遇到内存泄漏、对象占用过大，或者面试时被问“对象在内存中长什么样”，你可能就会意识到，事情没有那么简单。"><meta name=application-name content="My cool site"><meta name=apple-mobile-web-app-title content="My cool site"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=http://example.org/posts/java/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/><link rel=prev href=http://example.org/posts/java%E5%B2%97%E4%BD%8D%E7%AE%80%E5%8E%86/><link rel=next href=http://example.org/posts/java/%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80%E5%AE%9E%E6%88%98%E7%94%A8-jol-%E5%B7%A5%E5%85%B7%E7%9C%8B%E7%9C%8B%E7%9C%9F%E5%AE%9E%E7%BB%93%E6%9E%84/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"JVM基础：Java对象的创建与内存布局：你以为的 new 不止 new","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/example.org\/posts\/java\/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80\/"},"genre":"posts","keywords":"java, JVM","wordcount":2377,"url":"http:\/\/example.org\/posts\/java\/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80\/","datePublished":"2025-04-27T16:52:52+08:00","dateModified":"2025-04-27T16:52:52+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"fulu"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=Fulur>Fulur</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=Fulur>Fulur</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">JVM基础：Java对象的创建与内存布局：你以为的 new 不止 new</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>fulu</a></span>&nbsp;<span class=post-category>included in <a href=/categories/jvm%E5%9F%BA%E7%A1%80/><i class="far fa-folder fa-fw" aria-hidden=true></i>JVM基础</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2025-04-27>2025-04-27</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;2377 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;5 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#你真的理解-new-吗>你真的理解 new 吗？</a></li><li><a href=#一对象是怎么被创建的jvm-的对象创建流程>一、对象是怎么被创建的？——JVM 的对象创建流程</a><ul><li><a href=#第一步检查类是否已加载初始化>第一步：检查类是否已加载、初始化</a></li><li><a href=#第二步在堆中分配内存>第二步：在堆中分配内存</a></li><li><a href=#第三步对象内存初始化为零值默认值>第三步：对象内存初始化为零值（默认值）</a></li><li><a href=#第四步设置对象头>第四步：设置对象头</a></li><li><a href=#第五步执行-init-构造方法>第五步：执行 <code>&lt;init></code> 构造方法</a></li><li><a href=#第六步返回对象引用>第六步：返回对象引用</a></li></ul></li><li><a href=#三java-对象在内存中的真实结构>三、Java 对象在内存中的真实结构</a><ul><li><a href=#1-对象头header>1. 对象头（Header）</a></li><li><a href=#2-实例数据区instance-data>2. 实例数据区（Instance Data）</a></li><li><a href=#3-对齐填充区padding>3. 对齐填充区（Padding）</a></li><li><a href=#-结构示意图>🔍 结构示意图：</a></li><li><a href=#-小结>✅ 小结：</a></li></ul></li></ul></nav></div></div><div class=content id=content><h2 id=你真的理解-new-吗>你真的理解 new 吗？</h2><p>“Java 中创建一个对象，不就是 new 一下吗？”这是许多开发者对对象创建的第一印象。但如果你曾经在生产环境遇到内存泄漏、对象占用过大，或者面试时被问“对象在内存中长什么样”，你可能就会意识到，事情没有那么简单。</p><p>今天，我们不谈语法，不谈封装继承多态，我们只谈：<strong>一个 Java 对象，在 JVM 中是怎么被创建出来的？它在内存里究竟长什么样？</strong></p><hr><h2 id=一对象是怎么被创建的jvm-的对象创建流程>一、对象是怎么被创建的？——JVM 的对象创建流程</h2><p><strong>Java中常见的 5 种对象创建方式：</strong></p><ol><li><code>new</code> 关键字（最常见）</li><li>反射 <code>Class.newInstance()</code>、<code>Constructor.newInstance()</code></li><li>克隆 <code>clone()</code></li><li>反序列化 <code>ObjectInputStream.readObject()</code></li><li>直接使用 <code>Unsafe.allocateInstance()</code>（跳过构造方法）</li></ol><p>但 <strong>无论哪种方式，底层最终都会调用 JVM 的对象分配逻辑</strong>。</p><p>我们就以最常见的 <code>new</code> 来展开。</p><hr><p><strong>对象创建流程：JVM 做了什么？</strong></p><p>当你执行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>User</span><span class=w> </span><span class=n>user</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>User</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p>JVM 做了下面这 6 步：</p><hr><h3 id=第一步检查类是否已加载初始化>第一步：检查类是否已加载、初始化</h3><p>JVM 首先会确保 <code>User</code> 类已经：</p><ul><li>被加载（类加载器已加载 class 文件） // todo: 类加载器以及双亲委派、类加载的五大阶段</li><li>被验证/准备/解析/初始化（前文讲过五大阶段）</li></ul><p>如果没有，JVM 会先加载类，执行 <code>&lt;clinit></code> 方法，完成类初始化。</p><hr><h3 id=第二步在堆中分配内存>第二步：在堆中分配内存</h3><p>JVM 会在堆中为对象分配一块内存，分为两种策略：</p><ul><li><strong>指针碰撞（Bump the Pointer）</strong>：内存连续，分配效率高（依赖 GC 的压缩整理）</li><li><strong>空闲列表（Free List）</strong>：内存不连续时使用，类似链表管理</li></ul><p>JVM 会根据当前堆的内存布局决定用哪种策略。</p><p>如果多个线程同时竞争堆内存，则需要加锁保证线程安全，效率低些。为了解决这个问题，我们可以引入：</p><ul><li><strong>TLAB（Thread Local Allocation Buffer）</strong>：如果开启了 TLAB，那么每个线程有一块私有分配区，分配内存时只需在线程内部 bump 指针即可，效率极高。
当然TLAB也有其缺点和问题，后面我们会专门写文章探讨。 // todo 多线程下的内存分配机制</li></ul><p>JVM 参数：<code>-XX:+UseTLAB</code> 可以控制是否启用 TLAB。</p><hr><h3 id=第三步对象内存初始化为零值默认值>第三步：对象内存初始化为零值（默认值）</h3><p>所有字段初始化为默认值（int 为 0，boolean 为 false，引用为 null）。</p><p>⚠️ 注意，这一步不是执行构造方法，仅做内存层面的初始化。</p><hr><h3 id=第四步设置对象头>第四步：设置对象头</h3><p>对象头会包括：</p><ul><li><strong>Mark Word</strong>：哈希码、GC 标记、锁信息</li><li><strong>Klass Pointer</strong>：指向对象的类型元数据（即 class 的方法区结构）</li><li>如果是数组，还会多一个<strong>数组长度字段</strong>。</li></ul><p>这一步完成后，对象已经拥有类型、状态信息。</p><hr><h3 id=第五步执行-init-构造方法>第五步：执行 <code>&lt;init></code> 构造方法</h3><p>JVM 调用 <code>&lt;init></code> 方法，按照你定义的构造器逻辑，初始化对象的实际字段值。</p><p>此时，Java 代码层面看到的初始化操作就开始发生。</p><hr><h3 id=第六步返回对象引用>第六步：返回对象引用</h3><p>创建完成后，返回堆中对象的引用，赋值给变量 <code>user</code>。</p><p>如果开启了逃逸分析且确定对象不会逃逸线程作用域，JVM 甚至会将对象分配在栈上（标量替换）—— 即所谓<strong>栈上分配</strong>。</p><hr><h2 id=三java-对象在内存中的真实结构>三、Java 对象在内存中的真实结构</h2><p>对象在代码中看起来是这样的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>User</span><span class=w> </span><span class=n>user</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>User</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p>但在内存中，它其实是一块结构严谨、精心排布的数据区域。要真正理解对象在 JVM 里的模样，我们要从<strong>对象头</strong>、<strong>实例数据区</strong>、以及<strong>对齐填充区</strong>这三部分说起。</p><hr><h3 id=1-对象头header>1. 对象头（Header）</h3><p>对象头是每个 Java 对象都必须携带的一部分，主要由两项组成：</p><h4 id=-mark-word标记字段>👉 Mark Word（标记字段）</h4><p>这是对象头中的前 8 个字节（在 64 位 JVM 且开启压缩指针的情况下），它用于存储以下信息： // todo 详解指针压缩</p><table><thead><tr><th>状态</th><th>含义</th></tr></thead><tbody><tr><td>hashCode</td><td>对象的 hash 值</td></tr><tr><td>GC 分代信息</td><td>对象的年龄（用于 GC）</td></tr><tr><td>锁标记</td><td>当前对象的锁状态</td></tr><tr><td>时间戳</td><td>可能用于偏向锁时间记录</td></tr></tbody></table><p>⚠️ 注意：当对象加锁时，Mark Word 会被替换成锁记录、指针等内容，hashCode 信息可能丢失或延迟计算。 // todo 加锁过程详解以及锁的分类和升级</p><h4 id=-klass-pointer类型指针>👉 Klass Pointer（类型指针）</h4><ul><li>占用 4 或 8 字节（取决于是否开启 <code>CompressedClassPointers</code>）。</li><li>指向方法区中的类元信息，表明这个对象是哪个类的实例。</li><li>也就是通过它，JVM 知道你调用的方法来自哪个类。</li></ul><h4 id=可选数组长度字段>👉（可选）数组长度字段</h4><p>如果是数组对象，对象头还会多一个 <code>length</code> 字段，记录数组的长度。</p><hr><h3 id=2-实例数据区instance-data>2. 实例数据区（Instance Data）</h3><p>紧接着对象头的，就是你在 Java 类中定义的实例变量，比如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>User</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>id</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>String</span><span class=w> </span><span class=n>name</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>这些成员变量会被按照以下原则依次排布：</p><ul><li><strong>类型相同的变量可能会被紧凑排列以节省空间</strong>，这叫做<strong>字段重排序</strong>。 // todo 详解字段重排，以及所产生的问题</li><li>Java 源码中字段的顺序，不一定等于内存中的排列顺序。</li><li>父类字段会被排在子类字段之前。</li></ul><p>举个例子，下面这个类：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Example</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>boolean</span><span class=w> </span><span class=n>a</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>b</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>boolean</span><span class=w> </span><span class=n>c</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>其实际内存排列可能是：</p><pre tabindex=0><code>[boolean a] [boolean c] [padding] [int b]
</code></pre><p>为了对齐 <code>int</code> 类型，JVM 会插入 padding 字节，使字段地址按 4 字节或 8 字节对齐。</p><hr><h3 id=3-对齐填充区padding>3. 对齐填充区（Padding）</h3><p>JVM 为了提高 CPU 访问效率，要求对象的总大小必须是 8 字节的倍数。如果对象的头 + 实例数据不是 8 的整数倍，JVM 会在对象末尾补上填充字节。</p><p>例如：</p><ul><li>一个对象总大小为 22 字节，JVM 会补充 2 字节填充，使其变为 24 字节。</li></ul><p>你可以通过参数 <code>-XX:ObjectAlignmentInBytes=16</code> 设置对齐单位（默认为 8）。</p><hr><h3 id=-结构示意图>🔍 结构示意图：</h3><pre tabindex=0><code>┌──────────────┬──────────────────────┬────────────────────┐
│  对象头       │   实例数据（字段）     │    对齐填充         │
│ (MarkWord +  │  int、long、String等 │  padding bytes     │
│  KlassPointer)│                      │                    │
└──────────────┴──────────────────────┴────────────────────┘
</code></pre><hr><h3 id=-小结>✅ 小结：</h3><p>Java 对象结构 = <strong>对象头（Header） + 实例数据（Instance Data）+ 对齐填充（Padding）</strong></p><ul><li>对象头是 JVM 内部操作的关键区域（锁、GC、hashCode 全靠它）。</li><li>字段在内存中的顺序可能与你想象的不一样，字段重排序是常见优化。</li><li>内存对齐规则虽然你感知不到，但它直接影响内存使用效率。</li></ul><hr><p>// todo 下一篇，我们将用一款神器 —— <strong>JOL（Java Object Layout）</strong>，亲手验证上面讲的结构，并可视化不同字段组合带来的内存差异。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2025-04-27</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=http://example.org/posts/java/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/ data-title="JVM基础：Java对象的创建与内存布局：你以为的 new 不止 new" data-hashtags=java,JVM><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=http://example.org/posts/java/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/ data-hashtag=java><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=http://example.org/posts/java/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/ data-title="JVM基础：Java对象的创建与内存布局：你以为的 new 不止 new"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=http://example.org/posts/java/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/ data-title="JVM基础：Java对象的创建与内存布局：你以为的 new 不止 new"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=http://example.org/posts/java/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/ data-title="JVM基础：Java对象的创建与内存布局：你以为的 new 不止 new"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/java/>Java</a>,&nbsp;<a href=/tags/jvm/>JVM</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/java%E5%B2%97%E4%BD%8D%E7%AE%80%E5%8E%86/ class=prev rel=prev title=我的简历><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>我的简历</a>
<a href=/posts/java/%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80%E5%AE%9E%E6%88%98%E7%94%A8-jol-%E5%B7%A5%E5%85%B7%E7%9C%8B%E7%9C%8B%E7%9C%9F%E5%AE%9E%E7%BB%93%E6%9E%84/ class=next rel=next title="JVM基础：对象布局实战：用 JOL 工具看看真实结构">JVM基础：对象布局实战：用 JOL 工具看看真实结构<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.146.7">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.3.0"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2022 - 2025</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>xxxx</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>