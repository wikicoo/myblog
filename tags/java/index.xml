<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on Fulur</title><link>http://example.org/tags/java/</link><description>Recent content in Java on Fulur</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Tue, 29 Apr 2025 17:52:52 +0800</lastBuildDate><atom:link href="http://example.org/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>JVM基础：Java 虚拟机模型</title><link>http://example.org/posts/java/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A8%A1%E5%9E%8B/</link><pubDate>Tue, 29 Apr 2025 17:52:52 +0800</pubDate><guid>http://example.org/posts/java/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A8%A1%E5%9E%8B/</guid><description>&lt;p>Java 虚拟机（Java Virtual Machine，JVM）是 Java 技术体系的核心。它屏蔽了底层硬件和操作系统的差异，实现了“一次编写，到处运行”（Write Once, Run Anywhere）的跨平台特性。要想深入掌握 Java 性能优化、排查线上问题，理解 JVM 的内部结构是必不可少的一环。&lt;/p></description></item><item><title>JVM基础：Java 内存模型（JMM）全解析</title><link>http://example.org/posts/java/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bjmm%E5%85%A8%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 28 Apr 2025 17:52:52 +0800</pubDate><guid>http://example.org/posts/java/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bjmm%E5%85%A8%E8%A7%A3%E6%9E%90/</guid><description>&lt;h2 id="一引言为什么需要-java-内存模型">一、引言：为什么需要 Java 内存模型？&lt;/h2>
&lt;p>在单线程程序中，变量的读取和写入是直观且一致的。但一旦进入多线程环境，情况就复杂得多——一个线程对变量所做的修改，另一个线程可能&lt;strong>看不到&lt;/strong>，也可能&lt;strong>看到不一致的中间状态&lt;/strong>。更令人困惑的是，这种问题即使在没有显式锁的代码中也可能悄然发生。你写下的代码语义清晰、逻辑无误，但却因为“看不见的顺序”而出现诡异的 bug。&lt;/p></description></item><item><title>JVM基础：对象大小与 JVM 参数的关系详解</title><link>http://example.org/posts/java/%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E4%B8%8E-jvm-%E5%8F%82%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 28 Apr 2025 16:52:52 +0800</pubDate><guid>http://example.org/posts/java/%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E4%B8%8E-jvm-%E5%8F%82%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB%E8%AF%A6%E8%A7%A3/</guid><description>&lt;p>Java 中对象的实际占用内存大小不仅与类中定义的字段有关，还受到 JVM 参数（特别是与指针压缩和对齐策略相关参数）的直接影响。理解这些参数对对象大小的影响，有助于在实际项目中进行精准内存估算与优化。&lt;/p></description></item><item><title>JVM基础：对象布局实战：用 JOL 工具看看真实结构</title><link>http://example.org/posts/java/%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80%E5%AE%9E%E6%88%98%E7%94%A8-jol-%E5%B7%A5%E5%85%B7%E7%9C%8B%E7%9C%8B%E7%9C%9F%E5%AE%9E%E7%BB%93%E6%9E%84/</link><pubDate>Sun, 27 Apr 2025 19:52:52 +0800</pubDate><guid>http://example.org/posts/java/%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80%E5%AE%9E%E6%88%98%E7%94%A8-jol-%E5%B7%A5%E5%85%B7%E7%9C%8B%E7%9C%8B%E7%9C%9F%E5%AE%9E%E7%BB%93%E6%9E%84/</guid><description>&lt;p>纸上得来终觉浅，我们现在来用工具实战验证一下：&lt;strong>Java 对象在内存中到底长什么样？&lt;/strong>&lt;/p>
&lt;p>JDK 提供了一款由官方支持的内存分析利器 —— &lt;strong>JOL（Java Object Layout）&lt;/strong>，它能让我们像 X 光一样看穿对象的每一个字节。&lt;/p></description></item><item><title>JVM基础：Java对象的创建与内存布局：你以为的 new 不止 new</title><link>http://example.org/posts/java/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</link><pubDate>Sun, 27 Apr 2025 16:52:52 +0800</pubDate><guid>http://example.org/posts/java/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</guid><description>&lt;h2 id="你真的理解-new-吗">你真的理解 new 吗？&lt;/h2>
&lt;p>“Java 中创建一个对象，不就是 new 一下吗？”这是许多开发者对对象创建的第一印象。但如果你曾经在生产环境遇到内存泄漏、对象占用过大，或者面试时被问“对象在内存中长什么样”，你可能就会意识到，事情没有那么简单。&lt;/p></description></item></channel></rss>